<!DOCTYPE html>
<html>
<head>
    <title>Virtual Research Experience</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 10px;
            background-color: #f5f5f5;
            padding: 0;
        }
        
        h1 {
            text-align: center;
            margin-top: 10px;
            font-size: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }
        
        /* Hamburger Menu Styles */
        .menu-toggle {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            width: 30px;
            gap: 5px;
            position: relative;
            z-index: 10;
        }
        
        .menu-toggle span {
            background-color: #333;
            height: 4px;
            border-radius: 2px;
            transition: transform 0.3s, background-color 0.3s;
        }
        
        .menu-container {
            position: relative;
            display: inline-block;
        }

        .menu-content {
            display: none !important;
            position: absolute;
            top: 40px;
            right: 0;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 4px;
            min-width: 200px;
            z-index: 5;
        }

        .menu-content.show {
            display: block !important;
        }
        
        .menu-content a {
            display: block;
            padding: 10px 20px;
            text-decoration: none;
            color: #333;
            border-bottom: 1px solid #eee;
        }
        
        .menu-content a:hover {
            background-color: #f5f5f5;
        }
        
        .menu-content a.active {
            background-color: #4CAF50;
            color: white;
        }
        
        .menu-container:hover .menu-content {
            display: block;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        @media (min-width: 768px) {
            .container {
                flex-direction: row;
            }
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 100%;
            flex: 1;
        }
        
        .simulation-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        @media (min-width: 768px) {
            .simulation-container {
                flex-direction: row;
            }
        }
        
        .simulation-window {
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 100%;
            position: relative;
            flex: 1;
        }
        
        .simulation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        
        .window-title {
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .food-indicator-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .food-indicator {
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .food-indicator:hover {
            transform: scale(1.05);
        }
        
        .food-default {
            background-color: #f5ebb9;
            color: #181818;
        }
        
        .food-oil {
            background-color: #ba0010;
            color: #ffffff;
        }
        
        .food-none {
            background-color: #ddd;
            color: #777;
        }
        
        canvas {
            border: 1px solid #333;
            width: 100%;
            display: block;
        }
        
        .simulationCanvas {
            background-color: #000;
            height: 200px;
        }
        
        .graphCanvas {
            background-color: #1a1a2e;
            height: 200px;
            border-top: 2px solid white; /* White line divider */
        }
        
        .food-types-container {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .food-type {
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            user-select: none;
            transition: transform 0.2s;
        }
        
        .food-default-type {
            background-color: #f7f3dc;
            color: #333;
        }
        
        .food-oil-type {
            background-color: #fb2839;
            color: #333;
        }
        
        .controls {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            font-size: 18px;
        }

        .controls label {
            font-size: 18px !important;
        }
        
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
            min-width: 120px;
            flex: 1;
        }
        
        .slider-container label {
            font-size: 18px;
            margin-bottom: 3px;
        }
        
        .slider-container input[type="range"] {
            width: 100%;
        }
        
        .slider-value {
            font-size: 18px;
            color: #666;
            text-align: center;
        }
        
        h2 {
            margin-top: 0;
            color: #333;
            font-size: 1.2rem;
        }
        
        h3 {
            font-size: 1.1rem;
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 767px) {
            body {
                margin: 5px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .slider-container {
                min-width: 100%;
            }
            
            button {
                width: 100%;
                padding: 12px;
                font-size: 1rem;
            }
        }
        
        /* Quiz Section */
        .quiz-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-top: 20px;
            display: none;
        }
        
        .quiz-section.active {
            display: block;
        }
        
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }
        
        .ranking-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }
        
        .ranking-item {
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
            cursor: grab;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ranking-item:hover {
            background: #e0e0e0;
        }
        
        .ranking-item.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }
        
        .ranking-number {
            font-weight: bold;
            font-size: 1.2em;
            min-width: 30px;
            text-align: center;
        }
        
        .ranking-content {
            flex: 1;
        }
        
        .result-section {
            display: none;
            padding: 20px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .result-section.show {
            display: block;
        }
        
        .result-section ul {
            font-weight: normal;
            text-align: left;
        }

        /* Status indicator for simulations */
        .status-indicator {
            font-size: 0.8rem;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .status-running {
            background-color: #4CAF50;
            color: white;
        }
        
        .status-paused {
            background-color: #FF9800;
            color: white;
        }
        
        .status-stopped {
            background-color: #f44336;
            color: white;
        }
        
        .hidden {
            display: none;
        }
        
        /* Ensure uniform canvas sizing */
        .simulationCanvas, .graphCanvas {
            width: 100%;
            height: 200px;
        }
        
        /* Drag placeholder */
        .drag-placeholder {
            height: 60px;
            background: #e0e0e0;
            border: 2px dashed #999;
            border-radius: 5px;
            margin: 5px 0;
        }
        
        /* Cell identification */
        .cell-id {
            font-size: 1.0rem;
            padding: 3px 6px;
            border-radius: 8px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .cell-green {
            background-color: #4CAF50;
            color: white;
        }
        
        .cell-blue {
            background-color: #2196F3;
            color: white;
        }
        
        .cell-purple {
            background-color: #9C27B0;
            color: white;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .simulation-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        @media (min-width: 768px) {
            .container {
                flex-direction: row;
            }
            
            .simulation-container {
                flex-direction: row;
            }
        }

        .panel {
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            flex: 1;
            /* display: flex; */
            /* flex-direction: column; */
            min-width: 250px;
        }

        .simulation-window {
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; /* Prevents flex items from overflowing */
        }


        .simulation-header {
            flex-shrink: 0;
        }

        .simulationCanvas, .graphCanvas {
            width: 100%;
            height: 200px;
            flex-shrink: 0;
        }

        /* Mobile-friendly ranking system */
        .ranking-item {
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
            cursor: grab;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            touch-action: manipulation; /* Better touch response */
        }

        /* Larger touch targets for mobile */
        @media (max-width: 767px) {
            .ranking-item {
                padding: 20px 15px;
                min-height: 60px;
                align-items: center;
            }
            
            .ranking-number {
                min-width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.3em;
            }
            
            .ranking-content {
                font-size: 1.1em;
                flex: 1;
            }
        }

        /* Alternative mobile interaction - buttons for reordering */
        .mobile-reorder-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 0.9em;
            display: none;
        }

        @media (max-width: 767px) {
            .mobile-reorder-btn {
                display: inline-block;
            }
        }
    </style>
</head>
<body>
    <h1>
        <div>Virtual Research Experience</div>
        <div class="menu-container">
            <div class="menu-toggle">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div class="menu-content">
                <a href="index.html">Cell Growth Simulator</a>
                <a href="#" class="active">Virtual Research Experience</a>
            </div>
        </div>
    </h1>
    
    <div class="container">
        <div class="simulation-container">
            <div class="simulation-window">
                <div class="simulation-header">
                    <div class="window-title">Sample A</div>
                    <div class="status-indicator status-paused" id="statusA">PAUSED</div>
                </div>
                <canvas id="simulationCanvasA" class="simulationCanvas"></canvas>
                <canvas id="graphCanvasA" class="graphCanvas"></canvas>
                <div class="cell-id cell-green" id="cellIdA">Cell: Green Circle</div>
            </div>
            
            <div class="simulation-window">
                <div class="simulation-header">
                    <div class="window-title">Sample B</div>
                    <div class="status-indicator status-paused" id="statusB">PAUSED</div>
                </div>
                <canvas id="simulationCanvasB" class="simulationCanvas"></canvas>
                <canvas id="graphCanvasB" class="graphCanvas"></canvas>
                <div class="cell-id cell-blue" id="cellIdB">Cell: Blue Square</div>
            </div>
            
            <div class="simulation-window">
                <div class="simulation-header">
                    <div class="window-title">Sample C</div>
                    <div class="status-indicator status-paused" id="statusC">PAUSED</div>
                </div>
                <canvas id="simulationCanvasC" class="simulationCanvas"></canvas>
                <canvas id="graphCanvasC" class="graphCanvas"></canvas>
                <div class="cell-id cell-purple" id="cellIdC">Cell: Purple Triangle</div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Instructions</h2>
            <p>Each sample contains a different microbial strain, as well as two substrates:</p>
            <div class="food-indicator food-default" id="Sucrose">Sucrose (Sugar source)</div>
            <div class="food-indicator food-oil" id="Hydrocarbons">Hydrocarbons (Oil contaminants)</div>

            <p>Using the growth curve data, rank the microbes according to their potential utility in oil spill bioremediation.</p>
            
            <div class="controls">
                <button id="startAllBtn">Start</button>
                <button id="pauseAllBtn">Pause</button>
                <button id="resetAllBtn">Reset Experiment</button>
            </div>
            
            <div class="controls">
                <label>
                    <input type="checkbox" id="showFoodCheckbox" checked> Show Substrate Count
                </label>
            </div>
        </div>
    </div>
    
    <div class="quiz-section" id="quizSection">
        <h2>Bioremediation Ranking</h2>
        <p>Rank the microbes from least to most effective for oil spill cleanup:</p>
        <p><strong>Least Effective</strong></p>
        
        <div class="ranking-container" id="rankingContainer">
            <!-- Populated by JavaScript -->
        </div>

        <p><strong>Most Effective</strong></p>
        
        <button id="submitQuizBtn">Submit Ranking</button>
        <div id="quizResult" class="result-section"></div>
    </div>
    
    <div class="result-section" id="resultSection">
        <!-- Results will be shown here -->
    </div>

    <script>
        // Hamburger menu functionality
        document.addEventListener('DOMContentLoaded', function() {
            const menuToggle = document.querySelector('.menu-toggle');
            const menuContent = document.querySelector('.menu-content');
            
            menuToggle.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event bubbling
                menuContent.classList.toggle('show');
            });
            
            // Close menu when clicking elsewhere
            document.addEventListener('click', function(e) {
                if (!menuToggle.contains(e.target) && !menuContent.contains(e.target)) {
                    menuContent.classList.remove('show');
                }
            });
            
            // Close menu when clicking a link
            const menuLinks = document.querySelectorAll('.menu-content a');
            menuLinks.forEach(link => {
                link.addEventListener('click', function() {
                    menuContent.classList.remove('show');
                });
            });
        });

        // Canvas setup for all simulations
        const canvases = {
            A: {
                sim: document.getElementById('simulationCanvasA'),
                graph: document.getElementById('graphCanvasA')
            },
            B: {
                sim: document.getElementById('simulationCanvasB'),
                graph: document.getElementById('graphCanvasB')
            },
            C: {
                sim: document.getElementById('simulationCanvasC'),
                graph: document.getElementById('graphCanvasC')
            }
        };
        
        const contexts = {};
        
        // Initialize all canvas contexts
        Object.keys(canvases).forEach(key => {
            contexts[key] = {
                sim: canvases[key].sim.getContext('2d'),
                graph: canvases[key].graph.getContext('2d')
            };
        });
        
        // Set canvas dimensions
        function resizeCanvases() {
            Object.keys(canvases).forEach(key => {
                const simCanvas = canvases[key].sim;
                const graphCanvas = canvases[key].graph;
                
                // Force uniform dimensions
                simCanvas.width = simCanvas.clientWidth;
                simCanvas.height = 200;
                graphCanvas.width = graphCanvas.clientWidth;
                graphCanvas.height = 200;
            });
        }
        
        // Call on load and resize
        window.addEventListener('load', function() {
            resizeCanvases();
            updateCellIdDisplays();
            populateRankingOptions();

            // Use mobile-friendly ranking system
            setTimeout(() => {
                setupMobileFriendlyRanking();
                setupRankingDragAndDrop(); // Keep drag-and-drop for desktop
            }, 100);

            Object.keys(simulations).forEach(key => initSimulation(key));
        });
        window.addEventListener('resize', resizeCanvases);

        // Constants
        const CELL_SPEED = 80; // Constant speed for all cells
        const TOTAL_FOOD_COUNT = 100; // Total food particles per experiment
        const PREFERRED_FOOD_THRESHOLD = 0.9; // 90% threshold
        const INITIAL_LAG_TIME = 5; // Increased initial lag time
        const PRIMARY_FOOD_REPRODUCTION_THRESHOLD = 2; // Dots needed for reproduction on preferred food
        const SECONDARY_FOOD_REPRODUCTION_THRESHOLD = 3; // Dots needed for reproduction on secondary food
        const SECONDARY_FOOD_LAG = 8; // 8 second lag before consuming secondary food
        let globalMaxCells = 1; // Normalizing y axis of the graph to the maximum cell count across all simulations
        let globalMaxFood = 1; // Normalizing y axis of the graph to the maximum food count across all simulations
        let showFoodCount = true;
        let useLogScale = false;
        
        // Define the three microbe types
        const microbeTypes = [
            'default-only',           // Only eats default food
            'oil-prefer-default',     // Eats both but prefers default
            'default-prefer-oil'      // Eats both but prefers oil
        ];
        
        // Microbe display info
        const microbeInfo = {
            'default-only': {
                name: 'Green Circle',
                color: '#4CAF50',
                shape: 'circle'
            },
            'oil-prefer-default': {
                name: 'Purple Triangle',
                color: '#CF42ED',
                shape: 'triangle'
            },
            'default-prefer-oil': {
                name: 'Blue Square',
                color: '#2196F3',
                shape: 'square'
            }
        };
        
        // Shuffle array to randomize microbe assignment
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // Assign microbes randomly to experiments, avoiding correct order
        function assignMicrobesWithoutCorrectOrder() {
            let assignment;
            let attempts = 0;
            const correctOrder = ['default-only', 'oil-prefer-default', 'default-prefer-oil'];
            
            do {
                const shuffledMicrobes = shuffleArray([...microbeTypes]);
                assignment = {
                    A: shuffledMicrobes[0],
                    B: shuffledMicrobes[1],
                    C: shuffledMicrobes[2]
                };
                
                // Check if this is the correct order
                const currentOrder = [assignment.A, assignment.B, assignment.C];
                const isCorrectOrder = JSON.stringify(currentOrder) === JSON.stringify(correctOrder);
                
                attempts++;
                // If we've tried too many times, just go with what we have
                if (attempts > 10) break;
                
                // Keep shuffling until we don't get the correct order
                if (!isCorrectOrder) break;
                
            } while (true);
            
            return assignment;
        }
        
        // Assign microbes randomly to experiments
        const microbeAssignment = assignMicrobesWithoutCorrectOrder();
        
        // Update cell ID displays
        function updateCellIdDisplays() {
            document.getElementById('cellIdA').innerHTML = `Cell: ${microbeInfo[microbeAssignment.A].name}`;
            document.getElementById('cellIdB').innerHTML = `Cell: ${microbeInfo[microbeAssignment.B].name}`;
            document.getElementById('cellIdC').innerHTML = `Cell: ${microbeInfo[microbeAssignment.C].name}`;
            
            // Update classes for colors
            document.getElementById('cellIdA').className = `cell-id cell-${microbeInfo[microbeAssignment.A].name.split(' ')[0].toLowerCase()}`;
            document.getElementById('cellIdB').className = `cell-id cell-${microbeInfo[microbeAssignment.B].name.split(' ')[0].toLowerCase()}`;
            document.getElementById('cellIdC').className = `cell-id cell-${microbeInfo[microbeAssignment.C].name.split(' ')[0].toLowerCase()}`;
        }
        
        // Simulation state for each window
        const simulations = {
            A: { 
                running: false, 
                time: 0, 
                cells: [], 
                foods: [], 
                history: [],
                lastTimestamp: 0,
                animationId: null,
                cellType: microbeAssignment.A,
                initialFoodCounts: {default: 50, oil: 50},
                dataGenerated: false
            },
            B: { 
                running: false, 
                time: 0, 
                cells: [], 
                foods: [], 
                history: [],
                lastTimestamp: 0,
                animationId: null,
                cellType: microbeAssignment.B,
                initialFoodCounts: {default: 50, oil: 50},
                dataGenerated: false
            },
            C: { 
                running: false, 
                time: 0, 
                cells: [], 
                foods: [], 
                history: [],
                lastTimestamp: 0,
                animationId: null,
                cellType: microbeAssignment.C,
                initialFoodCounts: {default: 50, oil: 50},
                dataGenerated: false
            }
        };
        
        // Status indicators
        const statusIndicators = {
            A: document.getElementById('statusA'),
            B: document.getElementById('statusB'),
            C: document.getElementById('statusC')
        };
        
        // Add food particles to simulation (always adds 50 of each type)
        function addFoodToSimulation(windowKey) {
            const sim = simulations[windowKey];
            
            // Add 50 default food particles
            for (let i = 0; i < 50; i++) {
                sim.foods.push({
                    x: Math.random() * canvases[windowKey].sim.width,
                    y: Math.random() * canvases[windowKey].sim.height,
                    type: 'default',
                    consumed: false
                });
            }
            
            // Add 50 oil food particles
            for (let i = 0; i < 50; i++) {
                sim.foods.push({
                    x: Math.random() * canvases[windowKey].sim.width,
                    y: Math.random() * canvases[windowKey].sim.height,
                    type: 'oil',
                    consumed: false
                });
            }
            
            draw(windowKey);
        }

        
        // Cell class with food preferences and shapes
        class Cell {
            constructor(x, y, cellType) {
                this.x = x;
                this.y = y;
                this.size = 8;
                
                // Constant speed for all cells
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * CELL_SPEED;
                this.vy = Math.sin(angle) * CELL_SPEED;
                
                this.cellType = cellType;
                this.consumedFood = { default: 0, oil: 0 };
                this.lastFedType = null;
                this.starvationTimer = 0;
                this.birthTime = 0;
                this.usingSecondaryFood = false;
                this.secondaryFoodSwitchTime = null;
                
                // Get shape info
                this.shape = microbeInfo[cellType].shape;
                this.color = microbeInfo[cellType].color;
            }
            
            update(canvas, deltaTime, foods, simulationTime, windowKey) {
                // Set birth time if not already set
                if (this.birthTime === 0) {
                    this.birthTime = simulationTime;
                }
                
                // Movement (constant speed)
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Boundary collision
                if (this.x < this.size) {
                    this.x = this.size;
                    this.vx = Math.abs(this.vx);
                }
                if (this.x > canvas.width - this.size) {
                    this.x = canvas.width - this.size;
                    this.vx = -Math.abs(this.vx);
                }
                if (this.y < this.size) {
                    this.y = this.size;
                    this.vy = Math.abs(this.vy);
                }
                if (this.y > canvas.height - this.size) {
                    this.y = canvas.height - this.size;
                    this.vy = -Math.abs(this.vy);
                }
                
                // Age timers
                this.starvationTimer += deltaTime;
                
                // Consume food based on cell type preference
                return this.consumeFood(foods, deltaTime, simulationTime, windowKey);
            }
            
            consumeFood(foods, deltaTime, simulationTime, windowKey) {
                // Find closest food based on preference
                let closestFood = null;
                let closestDistance = Infinity;
                
                const sim = simulations[windowKey];
                const foodCounts = this.getFoodCounts(sim.foods);
                
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    if (!food.consumed) {
                        const dx = this.x - food.x;
                        const dy = this.y - food.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Preference logic based on food availability
                        if (this.shouldEatFood(food.type, foodCounts, sim.initialFoodCounts, simulationTime)) {
                            if (distance < closestDistance && distance < this.size + 5) {
                                closestDistance = distance;
                                closestFood = food;
                            }
                        }
                    }
                }
                
                // Consume the food if found
                if (closestFood) {
                    closestFood.consumed = true;
                    this.consumedFood[closestFood.type]++;
                    this.lastFedType = closestFood.type;
                    this.starvationTimer = 0;
                    
                    // Update secondary food usage
                    this.updateSecondaryFoodUsage(closestFood.type, foodCounts, sim.initialFoodCounts, simulationTime);
                }
                
                // Die if starved too long
                if (this.starvationTimer > 15) {
                    return 'die';
                }
                
                // Reproduce based on food consumption
                let shouldReproduce = false;
                let foodTypeToReset = null;
                
                // Check reproduction conditions based on cell type
                switch (this.cellType) {
                    case 'default-only':
                        // Only eats default food
                        if (this.consumedFood.default >= PRIMARY_FOOD_REPRODUCTION_THRESHOLD) {
                            shouldReproduce = true;
                            foodTypeToReset = 'default';
                        }
                        break;
                        
                    case 'default-prefer-oil':
                        // Prefers oil, then default
                        if (this.usingSecondaryFood) {
                            // Using secondary (default) food
                            if (this.consumedFood.default >= SECONDARY_FOOD_REPRODUCTION_THRESHOLD) {
                                shouldReproduce = true;
                                foodTypeToReset = 'default';
                            }
                        } else {
                            // Using primary (oil) food
                            if (this.consumedFood.oil >= PRIMARY_FOOD_REPRODUCTION_THRESHOLD) {
                                shouldReproduce = true;
                                foodTypeToReset = 'oil';
                            }
                        }
                        break;
                        
                    case 'oil-prefer-default':
                        // Prefers default, then oil
                        if (this.usingSecondaryFood) {
                            // Using secondary (oil) food
                            if (this.consumedFood.oil >= SECONDARY_FOOD_REPRODUCTION_THRESHOLD) {
                                shouldReproduce = true;
                                foodTypeToReset = 'oil';
                            }
                        } else {
                            // Using primary (default) food
                            if (this.consumedFood.default >= PRIMARY_FOOD_REPRODUCTION_THRESHOLD) {
                                shouldReproduce = true;
                                foodTypeToReset = 'default';
                            }
                        }
                        break;
                        
                    case 'both-no-preference':
                        // Eats both equally, check whichever has enough
                        if (this.consumedFood.default >= PRIMARY_FOOD_REPRODUCTION_THRESHOLD) {
                            shouldReproduce = true;
                            foodTypeToReset = 'default';
                        } else if (this.consumedFood.oil >= PRIMARY_FOOD_REPRODUCTION_THRESHOLD) {
                            shouldReproduce = true;
                            foodTypeToReset = 'oil';
                        }
                        break;
                }
                
                if (shouldReproduce && 
                    (simulationTime - this.birthTime) >= INITIAL_LAG_TIME) {
                    // Reset the food counter that triggered reproduction
                    if (foodTypeToReset) {
                        this.consumedFood[foodTypeToReset] = 0;
                    }
                    return 'reproduce';
                }
                
                return null;
            }
            
            getFoodCounts(foods) {
                const counts = {default: 0, oil: 0};
                foods.forEach(food => {
                    if (!food.consumed) {
                        counts[food.type]++;
                    }
                });
                return counts;
            }
            
            shouldEatFood(foodType, currentFoodCounts, initialFoodCounts, simulationTime) {
                // Diauxic growth preference logic based on food availability
                switch (this.cellType) {
                    case 'default-only':
                        return foodType === 'default';
                    case 'default-prefer-oil':
                        // Prefer oil, but eat default when oil is mostly consumed
                        if (foodType === 'oil') return true;
                        if (foodType === 'default') {
                            // Check if oil is mostly consumed (90% threshold)
                            const oilConsumedRatio = initialFoodCounts.oil > 0 ? 
                                (initialFoodCounts.oil - currentFoodCounts.oil) / initialFoodCounts.oil : 1;
                            
                            // Only switch to secondary food after 3-second lag
                            if (oilConsumedRatio >= PREFERRED_FOOD_THRESHOLD) {
                                if (this.secondaryFoodSwitchTime === null) {
                                    this.secondaryFoodSwitchTime = simulationTime;
                                }
                                return (simulationTime - this.secondaryFoodSwitchTime) >= SECONDARY_FOOD_LAG;
                            } else {
                                this.secondaryFoodSwitchTime = null;
                            }
                            return false;
                        }
                        return false;
                    case 'oil-prefer-default':
                        // Prefer default, but eat oil when default is mostly consumed
                        if (foodType === 'default') return true;
                        if (foodType === 'oil') {
                            // Check if default is mostly consumed (90% threshold)
                            const defaultConsumedRatio = initialFoodCounts.default > 0 ? 
                                (initialFoodCounts.default - currentFoodCounts.default) / initialFoodCounts.default : 1;
                            
                            // Only switch to secondary food after 3-second lag
                            if (defaultConsumedRatio >= PREFERRED_FOOD_THRESHOLD) {
                                if (this.secondaryFoodSwitchTime === null) {
                                    this.secondaryFoodSwitchTime = simulationTime;
                                }
                                return (simulationTime - this.secondaryFoodSwitchTime) >= SECONDARY_FOOD_LAG;
                            } else {
                                this.secondaryFoodSwitchTime = null;
                            }
                            return false;
                        }
                        return false;
                    case 'both-no-preference':
                        return true;
                    default:
                        return true;
                }
            }
            
            updateSecondaryFoodUsage(foodType, currentFoodCounts, initialFoodCounts, simulationTime) {
                // Update whether the cell is currently using secondary food
                switch (this.cellType) {
                    case 'default-prefer-oil':
                        // Using secondary food (default) when oil is mostly consumed
                        if (foodType === 'default') {
                            const oilConsumedRatio = initialFoodCounts.oil > 0 ? 
                                (initialFoodCounts.oil - currentFoodCounts.oil) / initialFoodCounts.oil : 1;
                            this.usingSecondaryFood = oilConsumedRatio >= PREFERRED_FOOD_THRESHOLD &&
                                (simulationTime - (this.secondaryFoodSwitchTime || 0)) >= SECONDARY_FOOD_LAG;
                        } else if (foodType === 'oil') {
                            this.usingSecondaryFood = false;
                        }
                        break;
                    case 'oil-prefer-default':
                        // Using secondary food (oil) when default is mostly consumed
                        if (foodType === 'oil') {
                            const defaultConsumedRatio = initialFoodCounts.default > 0 ? 
                                (initialFoodCounts.default - currentFoodCounts.default) / initialFoodCounts.default : 1;
                            this.usingSecondaryFood = defaultConsumedRatio >= PREFERRED_FOOD_THRESHOLD &&
                                (simulationTime - (this.secondaryFoodSwitchTime || 0)) >= SECONDARY_FOOD_LAG;
                        } else if (foodType === 'default') {
                            this.usingSecondaryFood = false;
                        }
                        break;
                    default:
                        this.usingSecondaryFood = false;
                }
            }
            
            draw(ctx) {
                ctx.save();
                ctx.fillStyle = this.color;
                
                // Draw different shapes based on cell type
                switch (this.shape) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'square':
                        ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
                        break;
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - this.size);
                        ctx.lineTo(this.x - this.size, this.y + this.size);
                        ctx.lineTo(this.x + this.size, this.y + this.size);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                
                // Draw nucleus (white circle in center)
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Initialize simulation
        function initSimulation(windowKey) {
            const sim = simulations[windowKey];
            sim.running = false;
            sim.time = 0;
            sim.cells = [];
            sim.foods = []; // Clear foods
            sim.history = [{time: 0, cells: 1, food: {default: 0, oil: 0}}];
            sim.lastTimestamp = 0;
            sim.initialFoodCounts = {default: 50, oil: 50};
            sim.dataGenerated = false;
            
            // Set the specific cell type for this window
            sim.cellType = microbeAssignment[windowKey];
            
            // Create initial cell (assigned microbe type)
            sim.cells.push(new Cell(
                Math.random() * (canvases[windowKey].sim.width - 20) + 10,
                Math.random() * (canvases[windowKey].sim.height - 20) + 10,
                sim.cellType
            ));
            
            // Add food particles for BOTH food types automatically
            addFoodToSimulation(windowKey);
            
            // Update status indicator
            updateStatusIndicator(windowKey);
            
            draw(windowKey);
            drawGraph(windowKey);
        }

        
        // Update status indicator
        function updateStatusIndicator(windowKey) {
            if (simulations[windowKey].running) {
                statusIndicators[windowKey].textContent = 'RUNNING';
                statusIndicators[windowKey].className = 'status-indicator status-running';
            } else {
                statusIndicators[windowKey].textContent = 'PAUSED';
                statusIndicators[windowKey].className = 'status-indicator status-paused';
            }
        }
        
        // Draw simulation
        function draw(windowKey) {
            const ctx = contexts[windowKey].sim;
            const canvas = canvases[windowKey].sim;
            const sim = simulations[windowKey];
            
            // Clear canvas
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw food
            sim.foods.forEach(food => {
                if (!food.consumed) {
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = food.type === 'default' ? '#f5ebb9' : '#fb2839';
                    ctx.fill();
                }
            });
            
            // Draw cells
            sim.cells.forEach(cell => cell.draw(ctx));
        }
        
        // Draw graph
        function drawGraph(windowKey) {
            const ctx = contexts[windowKey].graph;
            const canvas = canvases[windowKey].graph;
            const sim = simulations[windowKey];

            if (sim.history.length < 2) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = 30;
            
            // Clear graph canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);
            
            // Determine max values for scaling
            const maxTime = Math.max(1, sim.history[sim.history.length - 1].time);
            const maxCells = globalMaxCells;
            const maxFoodDefault = Math.max(1, ...sim.history.map(p => p.food.default));
            const maxFoodOil = Math.max(1, ...sim.history.map(p => p.food.oil));
            const maxFoodTotal = globalMaxFood;
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines
            for (let i = 0; i <= 10; i++) {
                const y = padding + (height - 2 * padding) * (1 - i / 10);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = padding + (width - 2 * padding) * (i / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            
            // Y axis
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            // X axis
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw cell count line (solid)
            ctx.beginPath();
            ctx.strokeStyle = '#4CAF50'; // Green
            ctx.lineWidth = 3;
            ctx.setLineDash([]); // Solid line
            
            sim.history.forEach((point, index) => {
                const x = padding + (point.time / maxTime) * (width - 2 * padding);
                
                // Apply log scale if enabled
                let y;
                if (useLogScale && point.cells > 0) {
                    const logMax = Math.log(maxCells);
                    const logValue = Math.log(point.cells);
                    y = height - padding - (logValue / logMax) * (height - 2 * padding);
                } else {
                    y = height - padding - (point.cells / maxCells) * (height - 2 * padding);
                }
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw default food count line (dashed)
            if (showFoodCount) {
                ctx.beginPath();
                ctx.strokeStyle = '#f5ebb9'; // Light Yellow
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]); // Dashed line
                
                sim.history.forEach((point, index) => {
                    const x = padding + (point.time / maxTime) * (width - 2 * padding);
                    const y = height - padding - (point.food.default / maxFoodTotal) * (height - 2 * padding);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw oil food count line (dotted)
                ctx.beginPath();
                ctx.strokeStyle = '#fb2839'; // Red
                ctx.lineWidth = 3;
                ctx.setLineDash([2, 2]); // Dotted line
                
                sim.history.forEach((point, index) => {
                    const x = padding + (point.time / maxTime) * (width - 2 * padding);
                    const y = height - padding - (point.food.oil / maxFoodTotal) * (height - 2 * padding);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                ctx.setLineDash([]); // Reset to solid
            }
            
            // Draw legend
            ctx.fillStyle = '#4CAF50';
            ctx.font = '16px Arial';
            ctx.fillText('Cells', width - 100, 20);
            
            if (showFoodCount) {
                ctx.fillStyle = '#f5ebb9';
                ctx.fillText('Sucrose', width - 100, 40);
                
                ctx.fillStyle = '#fb2839';
                ctx.fillText('Hydrocarbons', width - 100, 60);
            }
        }
        
        // Simulation loop
        function simulationLoop(windowKey, timestamp) {
            const sim = simulations[windowKey];
            
            if (!sim.running) return;
            
            if (!sim.lastTimestamp) sim.lastTimestamp = timestamp;
            const deltaTime = (timestamp - sim.lastTimestamp) / 1000; // Convert to seconds
            sim.lastTimestamp = timestamp;
            
            sim.time += deltaTime;

            // Update global max values every 2 seconds to keep graph scaling consistent across simulations
            if (Math.floor(sim.time) % 2 === 0) { // Every 2 seconds
                updateGlobalMaxValues();
            }
            
            // Mark that data has been generated
            if (!sim.dataGenerated) {
                sim.dataGenerated = true;
            }
            
            // Update cells
            const newCells = [];
            for (let i = sim.cells.length - 1; i >= 0; i--) {
                const result = sim.cells[i].update(canvases[windowKey].sim, deltaTime, sim.foods, sim.time, windowKey);
                
                if (result === 'die') {
                    // Remove cell
                    sim.cells.splice(i, 1);
                } else if (result === 'reproduce') {
                    // Add new cell
                    const parent = sim.cells[i];
                    const angle = Math.random() * Math.PI * 2;
                    newCells.push(new Cell(
                        parent.x + Math.cos(angle) * 15,
                        parent.y + Math.sin(angle) * 15,
                        parent.cellType
                    ));
                }
            }
            sim.cells.push(...newCells);

            // Add to history every 0.5 seconds
            if (sim.history.length === 0 || sim.time - sim.history[sim.history.length - 1].time > 0.5) {
                const foodCount = {default: 0, oil: 0};
                sim.foods.forEach(food => {
                    if (!food.consumed) {
                        foodCount[food.type]++;
                    }
                });
                
                sim.history.push({
                    time: sim.time,
                    cells: sim.cells.length,
                    food: foodCount
                });
                
                // Limit history to last 500 points for performance (increased from 100)
                if (sim.history.length > 500) {
                    sim.history.shift();
                }
            }
            
            draw(windowKey);
            drawGraph(windowKey);
            
            // Stop if no cells left
            if (sim.cells.length === 0) {
                pauseSimulation(windowKey);
                checkAndShowQuiz();
                return;
            }
            
            sim.animationId = requestAnimationFrame((timestamp) => simulationLoop(windowKey, timestamp));
        }

        function updateGlobalMaxValues() {
            // Find max values across all simulations
            let maxCellsAcrossAll = 1;
            let maxFoodAcrossAll = 1;
            
            Object.keys(simulations).forEach(key => {
                const sim = simulations[key];
                if (sim.history.length > 0) {
                    const maxCells = Math.max(1, ...sim.history.map(p => p.cells));
                    const maxFood = Math.max(1, ...sim.history.map(p => Math.max(p.food.default, p.food.oil)));
                    maxCellsAcrossAll = Math.max(maxCellsAcrossAll, maxCells);
                    maxFoodAcrossAll = Math.max(maxFoodAcrossAll, maxFood);
                }
            });
            
            globalMaxCells = maxCellsAcrossAll;
            globalMaxFood = maxFoodAcrossAll;
        }
        
        // Start simulation
        function startSimulation(windowKey) {
            const sim = simulations[windowKey];
            sim.running = true;
            updateStatusIndicator(windowKey);
            
            // Record initial food counts when starting
            if (!sim.dataGenerated) {
                sim.initialFoodCounts = {default: 50, oil: 50};
            }
            
            if (!sim.animationId) {
                sim.lastTimestamp = 0;
                sim.animationId = requestAnimationFrame((timestamp) => simulationLoop(windowKey, timestamp));
            }
        }


        
        // Pause simulation
        function pauseSimulation(windowKey) {
            simulations[windowKey].running = false;
            updateStatusIndicator(windowKey);
            if (simulations[windowKey].animationId) {
                cancelAnimationFrame(simulations[windowKey].animationId);
                simulations[windowKey].animationId = null;
            }
        }
        
        // Reset simulation
        function resetSimulation(windowKey) {
            pauseSimulation(windowKey);
            initSimulation(windowKey);
        }
        
        // Event Listeners for control buttons
        document.getElementById('startAllBtn').addEventListener('click', () => {
            Object.keys(simulations).forEach(key => startSimulation(key));
        });
        
        document.getElementById('pauseAllBtn').addEventListener('click', () => {
            Object.keys(simulations).forEach(key => pauseSimulation(key));
        });
        
        document.getElementById('resetAllBtn').addEventListener('click', () => {
            Object.keys(simulations).forEach(key => resetSimulation(key));
        });
        
        // Setup checkbox event listeners
        document.getElementById('showFoodCheckbox').addEventListener('change', function() {
            showFoodCount = this.checked;
            Object.keys(simulations).forEach(key => drawGraph(key));
        });
        
        // Check if all simulations are stopped and show quiz
        function checkAndShowQuiz() {
            const allStopped = Object.values(simulations).every(sim => !sim.running);
            if (allStopped) {
                document.getElementById('quizSection').style.display = 'block';
            }
        }

        function setupMobileFriendlyRanking() {
            // Check if we're on a mobile device
            const isMobile = window.innerWidth <= 767;
            
            if (isMobile) {
                const container = document.getElementById('rankingContainer');
                const items = Array.from(container.querySelectorAll('.ranking-item'));
                
                items.forEach((item, index) => {
                    // Remove any existing buttons first to prevent duplicates
                    const existingButtons = item.querySelectorAll('.mobile-reorder-btn');
                    existingButtons.forEach(btn => btn.remove());
                    
                    // Add move up button (except for first item)
                    if (index > 0) {
                        const upBtn = document.createElement('button');
                        upBtn.className = 'mobile-reorder-btn';
                        upBtn.textContent = '';
                        upBtn.onclick = function(e) {
                            e.stopPropagation(); // Prevent event bubbling
                            const prevSibling = item.previousElementSibling;
                            if (prevSibling) {
                                container.insertBefore(item, prevSibling);
                                setupMobileFriendlyRanking(); // Re-setup buttons
                                updateRankingNumbers();
                            }
                        };
                        item.appendChild(upBtn);
                    }
                    
                    // Add move down button (except for last item)
                    if (index < items.length - 1) {
                        const downBtn = document.createElement('button');
                        downBtn.className = 'mobile-reorder-btn';
                        downBtn.textContent = '';
                        downBtn.onclick = function(e) {
                            e.stopPropagation(); // Prevent event bubbling
                            const nextSibling = item.nextElementSibling;
                            if (nextSibling) {
                                container.insertBefore(nextSibling, item);
                                setupMobileFriendlyRanking(); // Re-setup buttons
                                updateRankingNumbers();
                            }
                        };
                        item.appendChild(downBtn);
                    }
                });
            }
        }

        // Setup drag and drop for ranking
        function setupRankingDragAndDrop() {
            const container = document.getElementById('rankingContainer');
            let draggedItem = null;
            
            // Add event listeners to all ranking items
            container.querySelectorAll('.ranking-item').forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    draggedItem = this;
                    setTimeout(() => this.classList.add('dragging'), 0);
                });
                
                item.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedItem = null;
                    
                    // Update numbering after drag
                    updateRankingNumbers();
                });
                
                item.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    const rect = this.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    
                    // Insert placeholder before or after based on mouse position
                    if (e.clientY < midpoint) {
                        container.insertBefore(getPlaceholder(), this);
                    } else {
                        container.insertBefore(getPlaceholder(), this.nextSibling);
                    }
                });
            });
            
            // Create a placeholder element
            function getPlaceholder() {
                let placeholder = document.querySelector('.drag-placeholder');
                if (!placeholder) {
                    placeholder = document.createElement('div');
                    placeholder.className = 'drag-placeholder';
                }
                return placeholder;
            }
            
            // Handle drop container
            container.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            container.addEventListener('drop', function(e) {
                e.preventDefault();
                const placeholder = document.querySelector('.drag-placeholder');
                
                if (placeholder && draggedItem) {
                    container.insertBefore(draggedItem, placeholder);
                    container.removeChild(placeholder);
                    updateRankingNumbers();
                }
            });
        }
        
        // Update ranking numbers
        function updateRankingNumbers() {
            const items = document.querySelectorAll('.ranking-item');
            items.forEach((item, index) => {
                item.querySelector('.ranking-number').textContent = index + 1;
            });
        }
        
        // Populate ranking options in random order
        function populateRankingOptions() {
            const container = document.getElementById('rankingContainer');
            container.innerHTML = ''; // Clear existing options
            
            const microbeData = [
                {type: 'default-only', name: 'Green Circle'},
                {type: 'oil-prefer-default', name: 'Purple Triangle'},
                {type: 'default-prefer-oil', name: 'Blue Square'}
            ];
            
            // Shuffle the array
            const shuffledMicrobes = shuffleArray([...microbeData]);
            
            // Populate the container
            shuffledMicrobes.forEach((microbe, index) => {
                const item = document.createElement('div');
                item.className = 'ranking-item';
                item.setAttribute('data-type', microbe.type);
                item.draggable = true;
                item.innerHTML = `
                    <div class="ranking-number">${index + 1}</div>
                    <div class="ranking-content">Cell: ${microbe.name}</div>
                `;
                container.appendChild(item);
            });
            
            // Add mobile buttons after population
            if (window.innerWidth <= 767) {
                setTimeout(() => {
                    setupMobileFriendlyRanking();
                }, 100);
            }
        }

        // Quiz functionality
        document.getElementById('submitQuizBtn').addEventListener('click', function() {
            const rankingItems = document.querySelectorAll('.ranking-item');
            const userRanking = Array.from(rankingItems).map(item => item.getAttribute('data-type'));
            
            // Correct ranking from least to most effective for oil spill cleanup:
            // default-only (least) -> oil-prefer-default (middle) -> default-prefer-oil (most)
            const correctRanking = ['default-only', 'oil-prefer-default', 'default-prefer-oil'];
            
            // Check if user ranking matches correct ranking
            const isCorrect = JSON.stringify(userRanking) === JSON.stringify(correctRanking);
            
            const resultSection = document.getElementById('quizResult');
            resultSection.innerHTML = `
                <p>${isCorrect ? 'Correct ranking!' : 'Incorrect ranking.'}</p>
                <p><strong>Explanation:</strong></p>
                <ul style="text-align: left">
                    <li>Green Circle: only eats sucrose, and therefore won't degrade oil.</li>
                    <li>Purple Triangle: eats hydrocarbons, but only after sucrose is depleted.</li>
                    <li>Blue Square: prefers hydrocarbons over sucrose, and is therefore the most effective bioremediator.</li>
                </ul>
                <button id="runNewExperimentBtn">Run New Experiment</button>
            `;
            resultSection.className = 'result-section show';
            
            // Setup button to run new experiment
            document.getElementById('runNewExperimentBtn').addEventListener('click', function() {
                location.reload();
            });
        });
        
        // Initialize everything when the page loads
        window.addEventListener('load', function() {
            resizeCanvases();
            updateCellIdDisplays();
            populateRankingOptions();
            setupRankingDragAndDrop();
            Object.keys(simulations).forEach(key => initSimulation(key));
        });
    </script>
</body>
</html>
