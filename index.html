<!DOCTYPE html>
<html>
<head>
    <title>Cell Growth Simulator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 10px;
            background-color: #f5f5f5;
            padding: 0;
        }
        
        h1 {
            text-align: center;
            margin-top: 10px;
            font-size: 1.5rem;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        @media (min-width: 768px) {
            .container {
                flex-direction: row;
            }
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 100%;
        }
        
        canvas {
            border: 1px solid #333;
            width: 100%;
            display: block;
        }
        
        #simulationCanvas {
            background-color: #000;
            height: 400px;
        }
        
        #graphCanvas {
            background-color: #1a1a2e;
            height: 400px;
        }
        
        .controls {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
            min-width: 120px;
            flex: 1;
        }
        
        .slider-container label {
            font-size: 12px;
            margin-bottom: 3px;
        }
        
        .slider-container input[type="range"] {
            width: 100%;
        }
        
        .slider-value {
            font-size: 12px;
            color: #666;
            text-align: center;
        }
        
        h2 {
            margin-top: 0;
            color: #333;
            font-size: 1.2rem;
        }
        
        h3 {
            font-size: 1.1rem;
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 767px) {
            body {
                margin: 5px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .slider-container {
                min-width: 100%;
            }
            
            button {
                width: 100%;
                padding: 12px;
                font-size: 1rem;
            }
        }
        
        /* Hide detailed stats */
        .stats-grid {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Cell Growth Simulator</h1>
    
    <div class="container">
        <div class="panel">
            <h2>Simulation</h2>
            <canvas id="simulationCanvas"></canvas>
            <br><br>
            <div class="controls">
                <button id="startBtn">Start</button>
                <button id="pauseBtn">Pause</button>
                <button id="resetBtn">Reset</button>
            </div>
            
            <h3>Configuration</h3>
            <div class="controls">
                <div class="slider-container">
                    <label for="initialCellsSlider">Initial Cells</label>
                    <input type="range" id="initialCellsSlider" min="1" max="10" value="1">
                    <span class="slider-value" id="initialCellsValue">1</span>
                </div>
                
                <div class="slider-container">
                    <label for="foodUnitsSlider">Food Units</label>
                    <input type="range" id="foodUnitsSlider" min="50" max="1000" value="500">
                    <span class="slider-value" id="foodUnitsValue">500</span>
                </div>
                
                <div class="slider-container">
                    <label for="lagTimeSlider">Lag Time (s)</label>
                    <input type="range" id="lagTimeSlider" min="0" max="10" value="3">
                    <span class="slider-value" id="lagTimeValue">3</span>
                </div>
                
                <div class="slider-container">
                    <label for="starvationTimeSlider">Starvation Time (s)</label>
                    <input type="range" id="starvationTimeSlider" min="1" max="20" value="10">
                    <span class="slider-value" id="starvationTimeValue">10</span>
                </div>
                
                <div class="slider-container">
                    <label for="reproductionThresholdSlider">Food to Reproduce</label>
                    <input type="range" id="reproductionThresholdSlider" min="1" max="10" value="3">
                    <span class="slider-value" id="reproductionThresholdValue">3</span>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Growth Curve</h2>
            <canvas id="graphCanvas"></canvas>

            <!-- Graph controls -->
            <div class="controls">
                <label>
                    <input type="checkbox" id="showFoodCheckbox" checked> Show Food Count
                </label>
                <label>
                    <input type="checkbox" id="logScaleCheckbox"> Log Scale
                </label>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const simCanvas = document.getElementById('simulationCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const simCtx = simCanvas.getContext('2d');
        const graphCtx = graphCanvas.getContext('2d');
        
        // Set canvas dimensions
        function resizeCanvases() {
            simCanvas.width = simCanvas.clientWidth;
            simCanvas.height = simCanvas.clientHeight || 400;
            graphCanvas.width = graphCanvas.clientWidth;
            graphCanvas.height = graphCanvas.clientHeight || 400;
        }
        
        // Call on load and resize
        window.addEventListener('load', resizeCanvases);
        window.addEventListener('resize', resizeCanvases);
        
        // Constants
        const CELL_SPEED = 100; // Constant speed for all cells
        const DOUBLING_TIME_VARIANCE = 0.1; // 10% variance in doubling times

        // Simulation state
        let simulationRunning = false;
        let simulationTime = 0;
        let lastTimestamp = 0;
        let cellCount = 1;
        let foodCount = 500;
        let cells = [];
        let foods = [];
        let animationId = null;
        let growthHistory = [{time: 0, cells: 1, food: 500}];
        let useLogScale = false;
        let starvationTime = 5; // seconds before cell dies
        let reproductionThreshold = 3; // food needed to reproduce
        let lagTime = 3; // seconds before cells can reproduce
        let lastHistoryUpdate = 0; // Track when we last added to history
        
        // Statistics tracking
        let totalCellsCreated = 1;
        let totalCellDeaths = 0;
        let totalReproductions = 0;
        let totalFoodConsumed = 0;
        let cellLifetimeSum = 0;
        let cellDeathCount = 0;
        
        // Configuration defaults
        let config = {
            initialCells: 1,
            foodUnits: 500
        };
        
        // DOM Elements
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const showFoodCheckbox = document.getElementById('showFoodCheckbox');
        const logScaleCheckbox = document.getElementById('logScaleCheckbox');
        
        // Slider elements
        const initialCellsSlider = document.getElementById('initialCellsSlider');
        const foodUnitsSlider = document.getElementById('foodUnitsSlider');
        const lagTimeSlider = document.getElementById('lagTimeSlider');
        const starvationTimeSlider = document.getElementById('starvationTimeSlider');
        const reproductionThresholdSlider = document.getElementById('reproductionThresholdSlider');
        const initialCellsValue = document.getElementById('initialCellsValue');
        const foodUnitsValue = document.getElementById('foodUnitsValue');
        const lagTimeValue = document.getElementById('lagTimeValue');
        const starvationTimeValue = document.getElementById('starvationTimeValue');
        const reproductionThresholdValue = document.getElementById('reproductionThresholdValue');
        
        // Event Listeners
        startBtn.addEventListener('click', startSimulation);
        pauseBtn.addEventListener('click', pauseSimulation);
        resetBtn.addEventListener('click', resetSimulation);
        showFoodCheckbox.addEventListener('change', drawGraph);
        logScaleCheckbox.addEventListener('change', () => { 
            useLogScale = logScaleCheckbox.checked; 
            drawGraph(); 
        });
        
        // Slider event listeners
        initialCellsSlider.addEventListener('input', function() {
            initialCellsValue.textContent = this.value;
            config.initialCells = parseInt(this.value);
        });
        
        foodUnitsSlider.addEventListener('input', function() {
            foodUnitsValue.textContent = this.value;
            config.foodUnits = parseInt(this.value);
        });
        
        lagTimeSlider.addEventListener('input', function() {
            lagTimeValue.textContent = this.value;
            lagTime = parseInt(this.value);
        });
        
        starvationTimeSlider.addEventListener('input', function() {
            starvationTimeValue.textContent = this.value;
            starvationTime = parseInt(this.value);
        });
        
        reproductionThresholdSlider.addEventListener('input', function() {
            reproductionThresholdValue.textContent = this.value;
            reproductionThreshold = parseInt(this.value);
        });
        
        // Cell class
        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 8;
                this.birthTime = simulationTime;
                
                // Give all cells the same speed but random direction
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * CELL_SPEED;
                this.vy = Math.sin(angle) * CELL_SPEED;
                
                this.consumedFood = 0;
                this.age = 0;
                this.lastFed = 0; // Time since last feeding
                this.reproductionTimer = 0; // Timer for next reproduction
                this.nextReproductionTime = this.getRandomDoublingTime(); // Random doubling time
            }
            
            getRandomDoublingTime() {
                // Generate a random doubling time with variance
                const baseDoublingTime = 1.0; // Base doubling time in seconds
                const variance = (Math.random() * 2 - 1) * DOUBLING_TIME_VARIANCE * baseDoublingTime;
                return Math.max(0.1, baseDoublingTime + variance); // Ensure minimum time
            }
            
            update(deltaTime) {
                // Move with velocity
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Boundary collision - bounce off walls
                if (this.x < this.size) {
                    this.x = this.size;
                    this.vx = Math.abs(this.vx);
                }
                if (this.x > simCanvas.width - this.size) {
                    this.x = simCanvas.width - this.size;
                    this.vx = -Math.abs(this.vx);
                }
                if (this.y < this.size) {
                    this.y = this.size;
                    this.vy = Math.abs(this.vy);
                }
                if (this.y > simCanvas.height - this.size) {
                    this.y = simCanvas.height - this.size;
                    this.vy = -Math.abs(this.vy);
                }
                
                // Age the cell
                this.age += deltaTime;
                this.lastFed += deltaTime;
                this.reproductionTimer += deltaTime;
                
                // Consume food if available - check proximity to food
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    if (!food.consumed) {
                        const dx = this.x - food.x;
                        const dy = this.y - food.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // If cell is close enough to food, consume it
                        if (distance < this.size + 3) {
                            food.consumed = true;
                            this.consumedFood += 1;
                            this.lastFed = 0; // Reset starvation timer
                            totalFoodConsumed++;
                            foodCount--;
                            break;
                        }
                    }
                }
                
                // Cell dies if it hasn't eaten in a while
                if (this.lastFed > starvationTime) {
                    // Record lifetime statistics
                    const lifetime = simulationTime - this.birthTime;
                    cellLifetimeSum += lifetime;
                    cellDeathCount++;
                    totalCellDeaths++;
                    return 'die';
                }
                
                // Reproduce when enough food consumed, past lag time, and reproduction timer expired
                if (this.consumedFood >= reproductionThreshold && 
                    (simulationTime - this.birthTime) >= lagTime && 
                    this.reproductionTimer >= this.nextReproductionTime) {
                    this.consumedFood = 0;
                    this.reproductionTimer = 0; // Reset reproduction timer
                    this.nextReproductionTime = this.getRandomDoublingTime(); // Set next reproduction time
                    totalReproductions++;
                    totalCellsCreated++;
                    return new Cell(this.x, this.y);
                }
                
                return null;
            }
            
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                
                // Color based on age and lag time
                const ageRatio = (simulationTime - this.birthTime) / lagTime;
                if (ageRatio < 1) {
                    // In lag phase - lighter color
                    const intensity = 100 + Math.floor(ageRatio * 100);
                    ctx.fillStyle = `rgb(255, ${intensity}, ${intensity})`; // Lighter red
                } else {
                    // Post-lag phase - full color
                    ctx.fillStyle = '#FF6B6B'; // Coral red
                }
                ctx.fill();
                
                // Draw nucleus
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 3, 0, Math.PI * 2);
                ctx.fillStyle = '#4ECDC4'; // Turquoise
                ctx.fill();
            }
        }
        
        // Initialize simulation
        function initSimulation() {
            cells = [];
            foods = [];
            simulationTime = 0;
            lastHistoryUpdate = 0;
            cellCount = config.initialCells;
            foodCount = config.foodUnits;
            growthHistory = [{time: 0, cells: cellCount, food: foodCount}];
            
            // Reset statistics
            totalCellsCreated = config.initialCells;
            totalCellDeaths = 0;
            totalReproductions = 0;
            totalFoodConsumed = 0;
            cellLifetimeSum = 0;
            cellDeathCount = 0;
            
            // Create initial cells with random positions but constant speed
            for (let i = 0; i < config.initialCells; i++) {
                const angle = Math.random() * Math.PI * 2;
                cells.push(new Cell(
                    Math.random() * (simCanvas.width - 20) + 10,
                    Math.random() * (simCanvas.height - 20) + 10
                ));
            }
            
            // Create food particles
            for (let i = 0; i < config.foodUnits; i++) {
                foods.push({
                    x: Math.random() * simCanvas.width,
                    y: Math.random() * simCanvas.height,
                    consumed: false
                });
            }
            
            draw();
            drawGraph();
        }
        
        // Simulation loop with proper delta time
        function simulationLoop(timestamp) {
            if (!simulationRunning) return;
            
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) / 1000; // Convert to seconds
            lastTimestamp = timestamp;
            
            simulationTime += deltaTime;
            
            // Update cells
            const newCells = [];
            for (let i = cells.length - 1; i >= 0; i--) {
                const result = cells[i].update(deltaTime);
                
                if (result === 'die') {
                    // Remove cell
                    cells.splice(i, 1);
                } else if (result instanceof Cell) {
                    // Add new cell
                    newCells.push(result);
                }
            }
            cells.push(...newCells);
            
            // Update stats
            cellCount = cells.length;
            foodCount = Math.max(0, foodCount);
            
            // Add to history every 0.5 seconds
            if (simulationTime - lastHistoryUpdate > 0.5) {
                growthHistory.push({
                    time: simulationTime,
                    cells: cellCount,
                    food: foodCount
                });
                lastHistoryUpdate = simulationTime;
            }
            
            draw();
            drawGraph();
            
            // Automatically stop when all cells die
            if (cells.length === 0) {
                pauseSimulation();
            }
            
            animationId = requestAnimationFrame(simulationLoop);
        }
        
        // Drawing functions
        function draw() {
            // Clear simulation canvas
            simCtx.fillStyle = 'black';
            simCtx.fillRect(0, 0, simCanvas.width, simCanvas.height);
            
            // Draw food particles
            simCtx.fillStyle = '#FFE66D'; // Yellow
            for (let i = 0; i < foods.length; i++) {
                const food = foods[i];
                if (!food.consumed) {
                    simCtx.beginPath();
                    simCtx.arc(food.x, food.y, 3, 0, Math.PI * 2);
                    simCtx.fill();
                }
            }
            
            // Draw cells
            cells.forEach(cell => cell.draw(simCtx));
        }
        
        function drawGraph() {
            if (growthHistory.length < 2) return;
            
            const ctx = graphCtx;
            const width = graphCanvas.width;
            const height = graphCanvas.height;
            const padding = 40;
            
            // Clear graph canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);
            
            // Determine max values for scaling
            const maxTime = Math.max(1, growthHistory[growthHistory.length - 1].time);
            const maxCells = Math.max(1, ...growthHistory.map(p => p.cells));
            const maxFood = Math.max(1, ...growthHistory.map(p => p.food));
            
            // Use log scale if selected
            const maxCellValue = useLogScale ? Math.log10(Math.max(1, maxCells)) : maxCells;
            const maxFoodValue = useLogScale ? Math.log10(Math.max(1, maxFood)) : maxFood;
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines for cells (left axis)
            for (let i = 0; i <= 10; i++) {
                const y = padding + (height - 2 * padding) * (1 - i / 10);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
                
                // Labels for cell count (left axis)
                ctx.fillStyle = 'rgba(255, 107, 107, 0.7)'; // Coral red
                ctx.font = '10px Arial';
                let value;
                if (useLogScale) {
                    value = Math.pow(10, i / 10 * maxCellValue);
                } else {
                    value = i / 10 * maxCellValue;
                }
                ctx.fillText(value.toFixed(value > 10 ? 0 : 1), 5, y + 4);
            }
            
            // Draw right axis labels for food (if showing food)
            if (showFoodCheckbox.checked) {
                for (let i = 0; i <= 10; i++) {
                    const y = padding + (height - 2 * padding) * (1 - i / 10);
                    
                    // Labels for food count (right axis)
                    ctx.fillStyle = 'rgba(255, 230, 109, 0.7)'; // Yellow
                    ctx.font = '10px Arial';
                    let value;
                    if (useLogScale) {
                        value = Math.pow(10, i / 10 * maxFoodValue);
                    } else {
                        value = i / 10 * maxFoodValue;
                    }
                    ctx.fillText(value.toFixed(value > 10 ? 0 : 1), width - 35, y + 4);
                }
            }
            
            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = padding + (width - 2 * padding) * (i / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '10px Arial';
                const time = (i / 10 * maxTime).toFixed(1);
                ctx.fillText(`${time}s`, x - 15, height - 5);
            }
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            
            // Y axis (left - cells)
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            // Y axis (right - food)
            ctx.beginPath();
            ctx.moveTo(width - padding, padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // X axis
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw cell count line
            ctx.beginPath();
            ctx.strokeStyle = '#FF6B6B'; // Coral red
            ctx.lineWidth = 2;
            
            growthHistory.forEach((point, index) => {
                const x = padding + (point.time / maxTime) * (width - 2 * padding);
                const value = useLogScale ? Math.log10(Math.max(1, point.cells)) : point.cells;
                const y = height - padding - (value / (maxCellValue || 1)) * (height - 2 * padding);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw food count line (on right axis if enabled)
            if (showFoodCheckbox.checked) {
                ctx.beginPath();
                ctx.strokeStyle = '#FFE66D'; // Yellow
                ctx.lineWidth = 2;
                
                growthHistory.forEach((point, index) => {
                    const x = padding + (point.time / maxTime) * (width - 2 * padding);
                    const value = useLogScale ? Math.log10(Math.max(1, point.food)) : point.food;
                    const y = height - padding - (value / (maxFoodValue || 1)) * (height - 2 * padding);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }
            
            // Draw legend
            ctx.fillStyle = '#FF6B6B'; // Coral red
            ctx.font = '12px Arial';
            ctx.fillText('Cells', width - 80, 20);
            
            if (showFoodCheckbox.checked) {
                ctx.fillStyle = '#FFE66D'; // Yellow
                ctx.fillText('Food', width - 80, 40);
            }
        }
        
        function startSimulation() {
            if (simulationRunning) return;
            simulationRunning = true;
            lastTimestamp = 0;
            animationId = requestAnimationFrame(simulationLoop);
        }
        
        function pauseSimulation() {
            simulationRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        function resetSimulation() {
            pauseSimulation();
            initSimulation();
        }
        
        // Initialize on load
        window.addEventListener('load', function() {
            resizeCanvases();
            initSimulation();
        });
    </script>
</body>
</html>
